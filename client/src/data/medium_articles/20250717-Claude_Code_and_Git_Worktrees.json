{
  "title": "Claude Code and Git Worktrees",
  "url": "https://medium.com/@kenji-onisuka/claude-code-and-git-worktrees-aa4c41e9faf9",
  "author": "Kenji",
  "publish_date": null,
  "read_time": "3 min read",
  "claps": 12,
  "comments": 0,
  "content": "Member-only story\n\nClaude Code and Git Worktrees\n\nScaling Agentic Coding with Parallel Claude Code\n\n12\n\nW\nhen I first experimented with Claude Code alongside my favorite IDE, I noticed something. While a single agent could tackle complex tasks, I often wished for multiple “opinions” on a design or implementation.\n\nWhat if I could generate different takes on the exact specification, side by side? That is actually documented in Anthropic’s Claude Code best practices — it’s about using Git worktrees — and it has reshaped how I approach non-deterministic AI workflows.\n\nWhy Parallel Agents Matter\n\nClaude Code breaks down engineering tasks into clear plans. Yet, because large language models produce varied outputs, running the same prompt twice can yield distinct results. Rather than fight that variability, we can embrace it — launching multiple agents in parallel and selecting the version that works best.\n\n“I’d rather review three implementations than roll the dice on a single outcome.”\n\n“I’d rather review three implementations than roll the dice on a single outcome.”\n\nHowever, a simple git checkout approach won’t work: all agents would compete for the same branch, causing merge conflicts and lost progress. That’s where Git worktrees come in.\n\nGit Worktrees Explained\n\nWorktrees provide physical isolation for each agent:\n\ngit worktree add -b task-1 ../trees/task-1\n\nRepeat for as many agents as you need (e.g., task-2, task-3).\n\nAutomate worktree creation with this create_worktree.sh script:\n\n#!/bin/bash\nBRANCH=$1\nmkdir -p ../trees\ngit worktree add -b $BRANCH ../trees/$BRANCH\ncd ../trees/$BRANCH\necho \"Worktree created for $BRANCH\"\n\nA Claude command can streamline this further: it creates worktrees, copies .env files, updates configs, and preps each environment. Then fires off the detailed plan (your task specifications) to each agent on Claude 4 simultaneously.\n\nParallel Execution in Action\n\nLet’s see how this works on a generic front-end project — DemoApp:\n\nPlan: Define the task clearly. For DemoApp, the goal might be: “Convert the main dashboard to a compact, information-dense layout with collapsible panels and updated typography.”\n\nAgents: Spin up three parallel agents in separate worktrees:\n\nfor i in {1..3}; do\n  git worktree add -b task-$i ../trees/task-$i\ndone\n\nRuntime: Each agent consumes tokens and completes. Because each worktree is isolated, they can install dependencies, run local servers (e.g., on ports 3001, 3002, 3003), and apply changes without conflict.\n\nTesting: Launch all three instances at once:\n\n./start-tree-clients.sh 3001 3002 3003\n\nIn Claude Code, define a custom slash command in .claude/commands/exe-parallel.md:\n\nExecute the plan in parallel agents: for i in {1..3}; do cd ../trees/ui-rewrite-$i && claude --model opus-4 \"/plan: Implement UI revamp\"; done\n\nRun with /exe-parallel.\n\nThis leverages LLMs’ probabilistic nature: Different agents produce unique perspectives, ideal for ambiguous tasks like UI design.\n\nMerging and Strategic Use\n\nPost-execution, review summaries. Commit changes per worktree, then merge the best (e.g., the modern version) into main: git merge task-rewrite-2.\n\nResolve conflicts as usual. Use this bash snippet to merge safely:\n\ngit checkout main\ngit merge task-rewrite-2 --no-ff -m \"Merge best UI revamp from agent 2\"\ngit push origin main\n\nUse this for:\n\nThis isn’t cheap (high token costs), but it maximizes compute: Generate n futures, pick the best, ship faster. As agentic tools like Claude Code evolve, parallel workflows position you to orchestrate, not just code.\n\nIn 2025’s AI landscape, scaling agents isn’t optional — it’s essential.",
  "scraped_at": "2025-07-17 12:15:33"
}