{
  "title": "How to Build Effective AI Agents: Lessons from Anthropic",
  "url": "https://medium.com/ai-unscripted/how-to-build-effective-ai-agents-lessons-from-anthropic-0e891a4ba7a3",
  "author": "Kenji",
  "publish_date": "Jan 4, 2025",
  "read_time": "5 min read",
  "claps": 208,
  "comments": 2,
  "content": "Aman Khanna\n highlighted\n\n1\n\nSavvas Theocharous\n highlighted\n\nMember-only story\n\nFeatured\n\nHow to Build Effective AI Agents: Lessons from Anthropic\n\nA Practical Guide to Creating Smart, Reliable AI Systems: From Workflows to Dynamic Problem Solvers\n\nKenji\n\nAI Unscripted\n\n208\n\n2\n\nB\nefore Christmas of 2024, Anthropic released an insightful blog post providing essential guidelines for building effective agents (see the original post at https://www.anthropic.com/research/building-effective-agents).\n\nBuilding effective agents\n\nA post for developers with advice and workflows for building effective AI agents\n\nwww.anthropic.com\n\nThese insights offer a practical roadmap to success for developers and organizations looking to create functional and reliable AI systems. While I encourage you to explore Anthropic’s detailed analysis, this article distills their key findings, adds practical experience, and offers hands-on advice to help you navigate this evolving landscape.\n\nWhat Are Agents?\n\nThe term “agent” in AI has several interpretations across the industry. Some view agents as fully autonomous systems operating independently over long periods, using multiple tools to complete complex tasks. Others see them as systems following specific, predefined workflows.\n\nHowever, Anthropic classifies these variations under the umbrella of “agentic systems” with two distinct architectural approaches:\n\nWorkflows: These are systems where LLMs and tools operate through predefined code paths. They function like a well-orchestrated process, following established routes to achieve consistent results.\n\nAgents: These systems allow LLMs to direct their processes and tool usage dynamically. They maintain control over accomplishing tasks, choosing their path as they work.\n\nWhen to Use Agents — And When Not To\n\nThe core principle Anthropic emphasizes is simplicity. Many applications that need complex agent systems work effectively with a single LLM call, retrieval, and well-chosen examples.\n\nWorkflows excel in predictable, well-defined tasks where consistency matters most. Agents prove valuable in open-ended challenges where fixed paths fall short.\n\nWorkflows excel in predictable, well-defined tasks where consistency matters most. Agents prove valuable in open-ended challenges where fixed paths fall short.\n\nConsider the trade-offs carefully. Like any sophisticated tool, agents come with processing time and resource costs. The benefits should justify these investments.\n\nFrameworks: A Critical Analysis\n\nThe AI framework landscape presents multiple options for building agent systems. Based on my experience with a few platforms, here’s my analysis of their strengths and limitations.\n\nFor a complete technical overview, I recommend reading Anthropic’s original blog post at https://www.anthropic.com/research/building-effective-agents.\n\nLangGraph by LangChain\n\nLangGraph offers precise control over agentic systems, providing a lower-level framework than traditional LangChain agents.\n\nPros: Effective integrations for chaining prompts and tool usage, excellent modularity for extensible systems, strong community support and documentation.\nCons: It takes time for beginners to master it, and there is a risk of extra complexity if not managed well.\n\nPros: Effective integrations for chaining prompts and tool usage, excellent modularity for extensible systems, strong community support and documentation.\n\nCons: It takes time for beginners to master it, and there is a risk of extra complexity if not managed well.\n\nPersonal Insight: Investing time to understand LangGraph’s modular design brings rewards in complex projects needing sophisticated chaining.\n\nCrewAI\n\nThis is my favorite framework; it lets you create AI teams where each agent has specific roles, tools, and goals, working together to accomplish complex tasks.\n\nPros: Strong decision-making abilities, work well with human oversight, good for mixed system types.\nCons: None that I’ve encountered in my work so far — it’s why this has become my go-to framework for team-based AI systems.\n\nPros: Strong decision-making abilities, work well with human oversight, good for mixed system types.\n\nCons: None that I’ve encountered in my work so far — it’s why this has become my go-to framework for team-based AI systems.\n\nPersonal Insight: It is worth the effort for advanced projects needing adaptability.\n\nBuilding Blocks of Agentic Systems\n\nCreating effective AI systems requires careful attention to fundamental components. Let’s examine the essential elements:\n\n1. The Augmented LLM\n\nEvery effective system needs an LLM enhanced with key abilities. Success comes from smart integration, not just raw processing power.\n\nCore Capabilities: Creating search queries, using external tools, and maintaining information through memory systems.\n\nPersonal Insight: The best systems focus on specific needs rather than adding every possible feature. Choose only what fits your task and ensure everything works together smoothly.\n\n2. Workflow Patterns\n\nPrompt Chaining: Creates sequential steps where each LLM call builds on previous results. Ideal for content creation, translation, and document structuring.\n\nRouting: Directs tasks to specialized components based on classification. Perfect for customer support and content moderation.\n\nParallelization: Processes multiple subtasks simultaneously or aggregates multiple attempts. Excellent for quality control and automated evaluations.\n\nOrchestrator-Workers: Manages task delegation and result synthesis. Suited for complex coding tasks and research projects.\n\nEvaluator-Optimizer: Refines outputs through feedback loops. Essential for high-precision tasks requiring iteration.\n\nHere are the basic codes for three simple multi-LLM workflows. They trade off cost or latency for potentially improved task performances:\n\ndef chain(input: str, prompts: List[str]) -> str:\n    \"\"\"Chain multiple LLM calls sequentially, passing results between steps.\"\"\"\n    result = input\n    for i, prompt in enumerate(prompts, 1):\n        print(f\"\\nStep {i}:\")\n        result = llm_call(f\"{prompt}\\nInput: {result}\")\n        print(result)\n    return result\n\ndef parallel(prompt: str, inputs: List[str], n_workers: int = 3) -> List[str]:\n    \"\"\"Process multiple inputs concurrently with the same prompt.\"\"\"\n    with ThreadPoolExecutor(max_workers=n_workers) as executor:\n        futures = [executor.submit(llm_call, f\"{prompt}\\nInput: {x}\") for x in inputs]\n        return [f.result() for f in futures]\n\ndef route(input: str, routes: Dict[str, str]) -> str:\n    \"\"\"Route input to specialized prompt using content classification.\"\"\"\n    # First determine appropriate route using LLM with chain-of-thought\n    print(f\"\\nAvailable routes: {list(routes.keys())}\")\n    selector_prompt = f\"\"\"\n    Analyze the input and select the most appropriate support team from these options: {list(routes.keys())}\n    First explain your reasoning, then provide your selection in this XML format:\n\n    <reasoning>\n    Brief explanation of why this ticket should be routed to a specific team.\n    Consider key terms, user intent, and urgency level.\n    </reasoning>\n\n    <selection>\n    The chosen team name\n    </selection>\n\n    Input: {input}\"\"\".strip()\n    \n    route_response = llm_call(selector_prompt)\n    reasoning = extract_xml(route_response, 'reasoning')\n    route_key = extract_xml(route_response, 'selection').strip().lower()\n    \n    print(\"Routing Analysis:\")\n    print(reasoning)\n    print(f\"\\nSelected route: {route_key}\")\n    \n    # Process input with selected specialized prompt\n    selected_prompt = routes[route_key]\n    return llm_call(f\"{selected_prompt}\\nInput: {input}\")\n\nImplementation Considerations\n\nKey Factors: Costs: Dynamic operations can increase resource usage. Errors: Complex systems require robust error handling and monitoring.\n\nBest Practices:\n\nFinal Thoughts\n\nCreating effective AI systems isn’t about complexity — it’s about building reliable solutions that serve specific needs.\n\nStart with straightforward workflows, refine through careful iteration, and use more complex approaches only when simpler ones won’t suffice.\n\nStart with straightforward workflows, refine through careful iteration, and use more complex approaches only when simpler ones won’t suffice.\n\nI recommend reading Anthropic’s original blog post for a deeper understanding of these concepts. Their comprehensive analysis provides valuable technical context for these practical guidelines.\n\nReferences:\n\nBuilding effective agents\n\nA post for developers with advice and workflows for building effective AI agents\n\nwww.anthropic.com\n\nanthropic-cookbook/patterns/agents at main · anthropics/anthropic-cookbook\n\nA collection of notebooks/recipes showcasing some fun and effective ways of using Claude. …\n\ngithub.com",
  "scraped_at": "2025-04-07 08:38:40"
}